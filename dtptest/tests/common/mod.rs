use log::{info, warn};
use ring::rand::*;
use std::net;
use std::net::SocketAddr;
pub mod client_fun;
pub mod server_fun;
use quiche::Config;
pub const MAX_DATAGRAM_SIZE: usize = 1350;
pub const HTTP_REQ_STREAM_ID: u64 = 4;
pub fn log_init() {
    env_logger::builder().is_test(true).init();
}
pub fn hex_dump(buf: &[u8]) -> String {
    let vec: Vec<String> = buf.iter().map(|b| format!("{:02x}", b)).collect();

    vec.join("")
}

pub fn log_socket_addr_type(addr: &std::net::SocketAddr) {
    match addr {
        SocketAddr::V4(addr) => {
            info!("will use v4 addr:{}", addr);
        },
        SocketAddr::V6(addr) => {
            info!("will use v6 addr:{}", addr);
        },
    }
}
/// Generate a stateless retry token.
///
/// The token includes the static string `"quiche"` followed by the IP address
/// of the client and by the original destination connection ID generated by the
/// client.
///
/// Note that this function is only an example and doesn't do any cryptographic
/// authenticate of the token. *It should not be used in production system*.
pub fn mint_token(hdr: &quiche::Header, src: &net::SocketAddr) -> Vec<u8> {
    let mut token = Vec::new();

    token.extend_from_slice(b"quiche");

    let addr = match src.ip() {
        std::net::IpAddr::V4(a) => a.octets().to_vec(),
        std::net::IpAddr::V6(a) => a.octets().to_vec(),
    };

    token.extend_from_slice(&addr);
    token.extend_from_slice(&hdr.dcid);

    token
}

/// Validates a stateless retry token.
///
/// This checks that the ticket includes the `"quiche"` static string, and that
/// the client IP address matches the address stored in the ticket.
///
/// Note that this function is only an example and doesn't do any cryptographic
/// authenticate of the token. *It should not be used in production system*.
pub fn validate_token<'a>(
    src: &net::SocketAddr, token: &'a [u8],
) -> Option<quiche::ConnectionId<'a>> {
    if token.len() < 6 {
        return None;
    }

    if &token[..6] != b"quiche" {
        return None;
    }

    let token = &token[6..];

    let addr = match src.ip() {
        std::net::IpAddr::V4(a) => a.octets().to_vec(),
        std::net::IpAddr::V6(a) => a.octets().to_vec(),
    };

    if token.len() < addr.len() || &token[..addr.len()] != addr.as_slice() {
        return None;
    }

    Some(quiche::ConnectionId::from_ref(&token[addr.len()..]))
}

pub fn dtp_config(is_server: bool) -> Config {
    let mut config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();
    if is_server {
        let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
        let cert_file_path = format!("{}/src", manifest_dir);
        let crt = format!("{}/cert.crt", cert_file_path);
        let key = format!("{}/cert.key", cert_file_path);
        info!("crt path {}", crt);
        config.load_cert_chain_from_pem_file(&crt).unwrap();
        config.load_priv_key_from_pem_file(&key).unwrap();
        config.enable_early_data();
    } else {
        config.verify_peer(false);
    }
    config
        .set_application_protos(&[
            b"hq-interop",
            b"hq-29",
            b"hq-28",
            b"hq-27",
            b"http/0.9",
        ])
        .unwrap();

    config.set_max_idle_timeout(5000);
    config.set_max_recv_udp_payload_size(MAX_DATAGRAM_SIZE);
    config.set_max_send_udp_payload_size(MAX_DATAGRAM_SIZE);
    config.set_initial_max_data(100_000_000);
    config.set_initial_max_stream_data_bidi_local(1_000_000_000);
    config.set_initial_max_stream_data_bidi_remote(1_000_000_000);
    config.set_initial_max_stream_data_uni(1_000_000);
    config.set_initial_max_streams_bidi(100000);
    config.set_initial_max_streams_uni(100000);
    config.set_disable_active_migration(true);
    config
}

pub fn generate_conn_id(data: &quiche::Header) -> Vec<u8> {
    let rng = SystemRandom::new();
    let conn_id_seed =
        ring::hmac::Key::generate(ring::hmac::HMAC_SHA256, &rng).unwrap();
    let conn_id = ring::hmac::sign(&conn_id_seed, &data.dcid);
    let conn_id = &conn_id.as_ref()[..quiche::MAX_CONN_ID_LEN];
    conn_id.to_vec()
}
